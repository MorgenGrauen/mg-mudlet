<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>krrrcks</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>krrrcks</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Krrrcks: Farb-Trigger</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kommunikation</name>
					<script>-- Keine Ahnung, ob das besser geht, aber ich will die ganze Zeile einfärben und nicht nur
-- den "Match".

selectCurrentLine()
fg(farben.vg.komm)
bg(farben.hg.komm)
resetFormat()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#00aaff</mFgColor>
					<mBgColor>#000000</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^.* teilt Dir mit: .*$</string>
						<string>^Du teilst .* mit: .*$</string>
						<string>Du sagst:</string>
						<string>sagt:</string>
						<string>Du fragst</string>
						<string>fragt:</string>
						<string>Wecker klingelt bei Dir.</string>
						<string>denkt:</string>
						<string>Matrix:</string>
						<string>[Team </string>
						<string>aus der Ferne</string>
						<string>in der Ferne</string>
						<string> fluestert Dir zu: </string>
						<string>Du fluesterst</string>
						<string> fragt Dich: </string>
						<string> ruft:</string>
						<string>Du rufst:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kampf: Zustand</name>
					<script>local zustand = {}

zustand["ist absolut fit."] = 1
zustand["ist leicht geschwaecht."] = 0.9 -- Kaempfer Fokus
zustand["ist schon etwas geschwaecht."] = 0.9 -- untersuche
zustand["fuehlte sich auch schon besser."] = 0.8 -- Kaempfer Fokus
zustand["fuehlte sich heute schon besser."] = 0.8 -- untersuche
zustand["ist leicht angekratzt."] = 0.7 -- Kaempfer Fokus
zustand["ist leicht angeschlagen."] = 0.7 -- untersuche
zustand["ist nicht mehr taufrisch."] = 0.6 -- Kaempfer Fokus
zustand["sieht nicht mehr taufrisch aus."] = 0.6 -- untersuche
zustand["sieht recht mitgenommen aus."] = 0.5 -- Kaempfer Fokus
zustand["macht einen mitgenommenen Eindruck."] = 0.5 -- untersuche
zustand["wankt bereits bedenklich."] = 0.4
zustand["ist in keiner guten Verfassung."] = 0.3
zustand["braucht dringend einen Arzt."] = 0.2
zustand["steht auf der Schwelle des Todes."]= 0.1


local ausgabe = zustand[matches[1]]

if ausgabe then
  ausgabe = " (" .. ausgabe*100 .. "%)"
else
  ausgabe = " (???%)"
end

selectCurrentLine()
fg(farben.vg.info)
bg(farben.hg.info)
echo(ausgabe)
resetFormat()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>ist absolut fit.</string>
						<string>ist leicht geschwaecht.</string>
						<string>ist schon etwas geschwaecht.</string>
						<string>fuehlte sich auch schon besser.</string>
						<string>fuehlte sich heute schon besser.</string>
						<string>ist leicht angekratzt.</string>
						<string>ist leicht angeschlagen.</string>
						<string>ist nicht mehr taufrisch.</string>
						<string>sieht nicht mehr taufrisch aus.</string>
						<string>sieht recht mitgenommen aus.</string>
						<string>macht einen mitgenommenen Eindruck.</string>
						<string>wankt bereits bedenklich.</string>
						<string>ist in keiner guten Verfassung.</string>
						<string>braucht dringend einen Arzt.</string>
						<string>steht auf der Schwelle des Todes.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kampf: Infos</name>
					<script>selectCurrentLine()
fg(farben.vg.info)
bg(farben.hg.info)
resetFormat()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>faellt tot zu Boden.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Kampf: Flucht</name>
					<script>selectCurrentLine()
fg(farben.vg.info)
bg(farben.hg.info)
resetFormat()
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Die Angst ist staerker als Du ... Du willst nur noch weg hier.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Alarm: Post</name>
					<script>selectCurrentLine()
fg(farben.vg.alarm)
bg(farben.hg.alarm)
resetFormat()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Du hast \d* neuen? Briefe? im Postamt liegen\.$</string>
						<string>Ein Postreiter ruft Dir aus einiger Entfernung zu, dass Du neue Post hast!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Para-/Normalwelt</name>
					<script>-- Prüfung über Portal 23

selectCurrentLine()

if (matches[3] == "gruenlich") then
    fg(farben.vg.info)
    bg(farben.hg.info)

    ME.para = 0
end

if (matches[3] == "roetlich") then
    fg(farben.vg.alarm)
    bg(farben.hg.alarm)
    ME.para = 1
end

zeigeRaum()
resetFormat()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*)Du bist hier im Innern einer (.*) schimmernden Kugel,$</string>
						<string>^(.*)Im Innern einer (.*) schimmernden Kugel.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Bewegung: Ausgaenge</name>
					<script>selectCaptureGroup(1)
fg(farben.vg.info)
bg(farben.hg.info)
resetFormat()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Es gibt (.*) sichtbare Ausgaenge:</string>
						<string>Es gibt einen sichtbaren Ausgang: </string>
						<string>Es gibt keinen sichtbaren Ausgang.</string>
						<string>Es gibt keine sichtbaren Ausgaenge.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>2</integer>
						<integer>2</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>krrrcks</name>
			<script></script>
			<command></command>
			<packageName>krrrcks</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: Kleinkram</name>
				<script>--[[ Hier sammel ich Kleinkram, der nirgendwo anders gut hinpasst. Kleinere Skripte
    und Aliase ]]--</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Umlaute</name>
					<script>-- echo("&lt;UMLAUTE herausgenommen&gt; &lt;"..command.."&gt;\n");
command = string.gsub(command, 'ü', 'ue' );
command = string.gsub(command, 'ö', 'oe' );
command = string.gsub(command, 'ä', 'ae' );
command = string.gsub(command, 'Ä', 'Ae' );
command = string.gsub(command, 'Ö', 'Oe' );
command = string.gsub(command, 'Ü', 'Ue' );
command = string.gsub(command, 'ß', 'ss' );

send(command);</script>
					<command></command>
					<packageName></packageName>
					<regex>ü|ö|ä|Ü|Ö|Ä|ß</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Haus betreten</name>
					<script>-- Mit "#haus&lt;name&gt;" ein Seherhaus aufschliessen und betreten;
-- wird der Name weggelassen, wird automatisch ME.name angehaengt.

local wessen = matches[2]

-- Leerzeichen entfernen - http://lua-users.org/wiki/StringTrim
wessen = wessen:match'^()%s*$' and '' or wessen:match'^%s*(.*%S)'

if wessen == "" then wessen = ME.name end

if wessen then
    send("schliesse haus von " .. wessen .. " auf")
    send("oeffne haus von " .. wessen)
    send("betrete haus von " .. wessen)
    send("schliesse haus von " .. wessen)
    send("schliesse haus von " .. wessen .. " ab")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^#haus(.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Hilfe</name>
					<script>fg("yellow")

echo([[
Folgende Sachen gibt es und funktionieren:

* Umlaute werden erkannt und durch passende Umschreibungen ersetzt.

* Einstellungen und auch Globale Variablen
In "Scripts-&gt;Einstellugnen" habe ich einige globale Variablen und
einstellbare Sachen hinterlegt:

ME: ME ist ein Table, in dem ich alle möglichen Informationen zum User speichere;
  hier landen bspw. der Name, aber auch in welcher Para-Welt man sich befindet etc.
  Soweit möglich werden die entsprechenden Werte bspw. aus GMCP-Nachrichten
  gezogen.
farben: In diesem Table verwalte ich die für die Trigger und Skripte zu verwendenden
  Farben.

* Farbtrigger
In Trigger befinden sich Farbtrigger, welche die Ebenen einfärben.

* Wegeskripte von tf
Ich hatte einige Wegeskripte bei tf, die insbesondere mit einem "/dopath"
zusammenarbeiteten. Ich habe diese nahezu 1:1 rekonstruiert, sie sind in den Skripten
und den Aliasen zu finden.

* Kleinkram
#haus&lt;name&gt; : Wenn man vor einem Seherhaus steht, kann man es damit
  aufschließen, betreten und wieder verschließen. Achtung: Kein Leerzeichen
  zwischen "#haus" und dem Namen!
]])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#help$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Home</name>
					<script>expandAlias("#go haus")
expandAlias("#haus")</script>
					<command></command>
					<packageName></packageName>
					<regex>^#home$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Kämpfer: Grüße</name>
					<script>send("stehe still")
send("gruesse "  .. matches[2])
</script>
					<command></command>
					<packageName></packageName>
					<regex>^#gruesse (.+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: Alte Wege</name>
				<script>-- Die alten tf-Wegeskripte.
</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Weg ablaufen</name>
					<script>-- Die alten tf-Wegeskripte.

--[[ Gestartet werden diese mit "#go &lt;ziel&gt;", dann wird
    Ziel ausgewählt und die Sachen zum Mud geschossen. Dabei
    ist zu beachten, dass die meisten Skripte bei einem Portal
    bzw. beim Sandtiger starten. ]]--

-- Als Beispiel zwei Wege: Sandtiger-Hochebene und zurueck.

wege.he = { "#dopath w n n w w w n nw nw nw w nw nw nw w w no no o no o o", "folge hund" }
wege.he_st = { "folge hund", "#dopath w w sw w sw sw o o so so so o so so so s o o o s s o" }

local kommandos = wege[matches[2]]

if type(kommandos) == "table" then
  alt_ws(kommandos)
else
  echo (string.format("Weg %s ist nicht bekannt.", matches[2]))
end

</script>
					<command></command>
					<packageName></packageName>
					<regex>^#go (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Altes dopath</name>
					<script>-- Ersetzt das alte tf-dopath; übergeben wird ein String mit
-- Ausgängen.

-- Bspw: "#dopath o o w n" macht dann jeweils send("o"),
-- send("o"), send("w"), send("n")

alt_dopath(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^#dopath (.*)$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>mapper</name>
			<script></script>
			<command></command>
			<packageName>mapper</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Befehle</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>mmode</name>
					<script>
setMapperMode(matches[2])

                </script>
					<command></command>
					<packageName></packageName>
					<regex>^mmode (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>marea</name>
					<script>
mapper.currentArea = matches[2]
echoM("Current Area: " .. mapper.currentArea)

                </script>
					<command></command>
					<packageName></packageName>
					<regex>^marea (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>minit</name>
					<script>
-- Dies setzt die Karte auf Werkszustand zurueck.

for i,name in pairs(getRooms()) do
    deleteRoom(i)
end

addRoom(1)
setRoomArea(1, findArea("world"))
setRoomIDbyHash(1, mapper.currentHash)
mapper.currentRoom = 1
centerview(1)

echoM("Neue Map initialisiert.")

                </script>
					<command></command>
					<packageName></packageName>
					<regex>^minit$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>mhilfe</name>
					<script>
local helptext = [[
  MORGENGRAUEN MAPPER SCHNELLEINSTIEG
  -----------------------------------

0. Konfiguration

    Das Skript "Konfiguration" kann vom Benutzer angepasst werden. Hier werden
    Dinge eingestellt wie z.B. die Farbe der Meldungen des Mappers.

1. Karte initialisieren

    Mit dem Befehl 'minit' wird eine frische neue Karte erstellt. Muss vor der
    ersten Benutzung des Mappers einmalig ausgefuehrt werden.

    Achtung! Dieser Befehl loescht ohne Nachfrage oder Reue die komplette Karte!

2. Mapper Modi

    Momentan beherrscht der Mapper zwei Arbeitsmodi: fix und auto.

    - fix:  Der Standardmodus. Die Map wird nicht veraendert. Falls der aktuelle
            Raum bekannt ist, wird die Position im Map-Fenster angezeigt.

    - auto: Auto-Mapping-Modus. Der Mapper versucht (mithilfe von GMCP-Raum-IDs)
            automatisch eine Karte aufzubauen (siehe unten).

    Mit dem Befehl 'mmode &lt;fixed|auto&gt;' kann zwischen den Modi gewechselt werden.

3. Der Automapper

    Der Automapper kann die vom MUD gesendeten Raum-IDs dazu verwenden,
    automatisch eine Karte aufzubauen. Dies geschieht wie folgt:

    *  Zuerst muss Automapper per 'mmode auto' aktiviert werden. Dies funktioniert
       nur, wenn die Position im MUD mit der aktuellen Position auf der Karte
       uebereinstimmt (da die Karte sonst inkonsistent wuerde).

    *  Bewegt man sich nun in den naechsten Raum, wird in der entsprechenden
       Richtung ein weiterer Raum erzeugt und eine Verbindung in diese Richtung
       erzeugt.

    *  Der Mapper kann (mithilfe von Raum-IDs) erkennen, wenn z.B. ein
       Kreisfoermiger Weg vorliegt, also wenn ein bisher unbekannter Ausgang
       in einen bekannten Raum fuehrt und wird die Verbindungen entsprechend
       Einrichten.

    *  Achtung! Die allermeisten Ausgaenge haben Rueckwege in genau der
       entgegengesetzten Richtung. Da das jedoch nicht immer der Fall ist,
       wird jede der beiden Richtungen als SEPARATE Verbindung behandelt.
       Sind z.B. Raum A und Raum B auf einer Nord-Sued-Achse in beide Richtungen
       verbunden, so existieren zwei Verbindungen. Eine von A nach B namens "s"
       und eine von B nach A namens "n".
       Diese Rueckwege werden vom Automapper nicht automatisch erstellt. Der erste
       Raumwechsel erzeugt also nur eine Verbindung in eine Richtung. Um den Rueck-
       weg auch zu verbinden, muss man zusaetzlich noch einen Schritt in die
       Gegenrichtung machen. Damit hat man dann eine Zwei-Wege-Verbindung.

    *  Da der Automapper sehr von den Raum-IDs abhaengig ist, kann er nicht mit
       Raeumen umgehen, die diese IDs nicht senden. Das ist z.B. bei vielen
       Labyrinthen der Fall, allerdings auch, wenn man z.B. blind ist oder der
       Raum zu dunkel ist (zum Mappen also immer Lichtquelle und Augenlicht
       dabeihaben ;)) Der Automapper wird sich in so einem Fall selbst deaktivieren
       und eine entsprechende Meldung ausgeben.

    *  Bei viel Lag wird man ebenfalls in Probleme beim Mappen laufen, da der
       Automapper nach jedem Schritt erst die Antwort des MUDs abwarten muss
       bevor er einen Raum / Ausgang erstellen kann. Waehrend dieser Zeit darf man
       keine weiteren Eingaben taetigen! (Also, beim Automappen einfach immer warten,
       bis die Raumbeschreibung ankommt)

4. Areas

    Karten in einem MUD koennen 1. sehr sehr gross werden und 2. nicht immer geometrisch
    plausibel sein. Das MG ist zwar in dieser Hinsicht recht ordentlich (die meisten
    Gegenden koennen sinnvoll auf einem karierten Papier aufgetragen werden), dennoch
    ist das nicht immer der Fall. Mudlet loest dieses Problem mit sog. 'Areas'.
    Eine Area ist ein zusammenhaengender Kartenabschnitt, der als Gesamtheit angezeigt wird,
    d.h. es macht Sinn, konsistenten Kartenabschnitten eine Area zuzuweisen und an Stellen,
    an denen "Brueche" in der Map sind eine neue Area anzufangen.
    Die Map-Ansicht in Mudlet wird immer nur die Area anzeigen, in der man sich gerade
    befindet. Wechselt man die Area, aendert sich auch der angezeigte Kartenabschnitt.
    Ausgaenge die in eine neue Area fuehren, werden als Pfeile angezeigt.

    Jeder Raum hat eine zugewiesene Area. Beim Mappen muss man darauf achten, dass diese
    Zuweisungen auch sinnvoll sind. Der Automapper besitzt immer eine "aktuelle Area",
    diese kann mit 'marea &lt;name&gt;' gesetzt werden. Immer wenn nun ein neuer Raum erstellt
    wird (siehe oben), wird diesem Raum die aktuelle Area zugewiesen.

    Betritt man einen bekannten Raum, so wird die aktuelle Area auf die Area des Raumes
    gesetzt. D.h. beim Automappen muss man nur darauf achten, 'marea &lt;name&gt;' auszufuehren,
    wenn man eine neue Area anfangen will. Macht man das nicht, so wird immer die aktuelle
    Area mit neuen Raeumen erweitert.
]]

echo(helptext .. "\n")

                </script>
					<command></command>
					<packageName></packageName>
					<regex>^mhilfe$</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>krrrcks</name>
			<packageName>krrrcks</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: Einstellungen</name>
				<packageName></packageName>
				<script>-- Einstellungen (Farben etc.)</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Spieler</name>
					<packageName></packageName>
					<script>-- Variablen zum Spieler

ME = {}
ME.name = "Jemand"
ME.stufe = 0

ME.para = 0
ME.vorsicht = 0
ME.fluchtrichtung = ""
ME.lp_alt = 0

GUI = {}
GUI.angezeigt = false
GUI.lp_anzeige_blinkt = false

wege = {}
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: Alte Wege</name>
				<packageName></packageName>
				<script>-- Damit ich vor Einsatz des Mappers schon mal herumirren kann,
-- hier ein paar Funktionen, um die bisherigen Wege nutzen zu können.

</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Wegeskripte fuer tf</name>
					<packageName></packageName>
					<script>function alt_dopath(wegestring)
  if not type(wegestring) == "string" then
        wegestring = ""
    end
    for w in string.gmatch(wegestring, "%a+") do
      send(w)
    end
end

function alt_ws(kommandos, lang)
    if not type(kommandos) == "table" then
        kommandos = {}
    end
    if not lang then
        send("ultrakurz")
    end
    for k,v in ipairs(kommandos) do
        -- Wenn "#dopath" oder "#go", dann das Ali ausführen
        if (type(v) == "string" and string.sub(v,1,7) == "#dopath")
            or (type(v) == "string" and string.sub(v,1,3) == "#go")
       then
            expandAlias(v)
        else
        -- sonst ohne Ali Ersetzung senden (erst mal keine weiteren Ersetzungen
        -- vorgesehen.
            send(v)
        end
    end
    if not lang then
        send("lang")
        send("schau")
    end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: Debug</name>
				<packageName></packageName>
				<script>-- Ein paar Debugging-Funktionen</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Debug Ausgabe</name>
					<packageName></packageName>
					<script>function debugText(text)
    echo("DEBUG: " .. text)
end

function debugDisplay(obj)
    echo("DEBUG: ")
    display(obj)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Krrrcks: GUI</name>
				<packageName></packageName>
				<script>-- Hierin sammel ich alles, was für die GUI von Wichtigkeit sein könnte

--[[
Etwas trickreich ist folgendes:
Der "Script name" (bspw. "zeigeVitaldaten" muss genau dem Funktionsnamen für
diese Funktion entsprechen, sonst tut das nicht).
]]--</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>initGMCP</name>
					<packageName></packageName>
					<script>function initGMCP()
    sendGMCP( [[Core.Supports.Debug 20 ]])
    sendGMCP( [[Core.Supports.Set [ "MG.char 1", "MG.room 1", "comm.channel 1" ] ]])
end</script>
					<eventHandlerList>
						<string>gmcp.Char</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>initBase</name>
					<packageName></packageName>
					<script>function initBase()
    ME.name = gmcp.MG.char.base.name
    ME.stufe = gmcp.MG.char.info.level

    if not GUI.angezeigt then
        initGUI()
        GUI.angezeigt = true
    end

end</script>
					<eventHandlerList>
						<string>gmcp.MG.char.base</string>
						<string>gmcp.MG.char.info</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>zeigeVitaldaten</name>
					<packageName></packageName>
					<script>function zeigeVitaldaten()

  -- GMCP Vitaldaten merken

  ME.lp = gmcp.MG.char.vitals.hp
  ME.lp_max = gmcp.MG.char.maxvitals.max_hp
  ME.kp = gmcp.MG.char.vitals.sp
  ME.kp_max = gmcp.MG.char.maxvitals.max_sp

  -- Werte der Balken aktualisieren

  GUI.lp_anzeige:setValue(ME.lp, ME.lp_max,
      "&lt;b&gt; " .. ME.lp .. "/" .. ME.lp_max .. "&lt;/b&gt; ")

  GUI.kp_anzeige:setValue(ME.kp, ME.kp_max,
      "&lt;b&gt; " .. ME.kp .. "/" .. ME.kp_max .. "&lt;/b&gt; ")

  -- Treffer? Dann LP Balken blinken lassen

  if ME.lp &lt; ME.lp_alt then
    -- echo("Au!")
    lp_anzeige_blinken(0.2)
  else
    if not GUI.lp_anzeige_blinkt then
      lp_anzeige_faerben()
    end
  end
  ME.lp_alt = ME.lp

end

function lp_anzeige_faerben()

  -- Je nach LP Verlust wird Farbe gruen/gelb/rot

  local lp_quote = ME.lp / ME.lp_max
  GUI.lp_anzeige:setColor(255 * (1 - lp_quote),
                          255 * lp_quote,
                          50)
end

function lp_anzeige_blinken(dauer)

  GUI.lp_anzeige_blinkt = true
  GUI.lp_anzeige:setColor(255, 0, 50) -- rot
  tempTimer(dauer, [[ lp_anzeige_entblinken() ]])

end

function lp_anzeige_entblinken()

  GUI.lp_anzeige_blinkt = false
  lp_anzeige_faerben()

end</script>
					<eventHandlerList>
						<string>gmcp.MG.char.vitals</string>
						<string>gmcp.MG.char.maxvitals</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>zeigeGift</name>
					<packageName></packageName>
					<script>function zeigeGift()

  ME.gift = gmcp.MG.char.vitals.poison
  local zeile = ""

  -- vergiftet?

  if ME.gift == 0 then
    r = 30
    g = 30
    b = 30
  else  -- Farbuebergang gelb-&gt;orange-&gt;rot
    r = 255
    g = 255 - ME.gift * 25
    b = 0
    zeile = "&lt;black&gt;G I F T"
  end

  -- Statuszeile aktualisieren

  GUI.gift:echo(zeile)
  GUI.gift:setColor(r, g, b)

end</script>
					<eventHandlerList>
						<string>gmcp.MG.char.vitals</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>zeigeVorsicht</name>
					<packageName></packageName>
					<script>function zeigeVorsicht()

  ME.vorsicht = gmcp.MG.char.wimpy.wimpy
  ME.fluchtrichtung = gmcp.MG.char.wimpy.wimpy_dir

  -- Prinz Eisenherz?

  if ME.vorsicht == 0 then
    ME.vorsicht = "NIX"
  end

  local zeile = "Vorsicht: " .. ME.vorsicht

  -- Fluchtrichtung anzeigen, nur wenn gesetzt

  if ME.fluchtrichtung ~= 0 then
    zeile = zeile .. ", FR: " .. ME.fluchtrichtung
  end

  -- Statuszeile aktualisieren

  GUI.vorsicht:echo(zeile)

end</script>
					<eventHandlerList>
						<string>gmcp.MG.char.wimpy</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>zeigeRaum</name>
					<packageName></packageName>
					<script>function zeigeRaum()

  ME.raum_kurz = gmcp.MG.room.info.short
  ME.raum_region = gmcp.MG.room.info.domain
  ME.raum_id = string.sub(gmcp.MG.room.info.id, 1, 5)

  -- Para?

  if ME.para &gt; 0 then
    ME.raum_region = "Para-" .. ME.raum_region
    r = 255
    g = 0
    b = 0
  else
    r = 30
    g = 30
    b = 30
  end

  -- Statuszeile aktualisieren

  GUI.spieler:echo(ME.name .. " [" .. ME.stufe .. "]")

  GUI.ort_raum:echo(ME.raum_kurz)
  GUI.ort_region:echo(ME.raum_region .. " [" .. ME.raum_id .. "]")

  GUI.ort_raum:setColor(r, g, b)
  GUI.ort_region:setColor(r, g, b)

end</script>
					<eventHandlerList>
						<string>gmcp.MG.room</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>zeigeEbenen</name>
					<packageName></packageName>
					<script>function zeigeEbenen()
  fg(farben.vg.ebenen)
  bg(farben.hg.ebenen)
  echo(gmcp.comm.channel.msg)
  resetFormat()
end</script>
					<eventHandlerList>
						<string>gmcp.comm.channel</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>initGUI</name>
					<packageName></packageName>
					<script>function initGUI()

  -- Textfenster begrenzen
  setBorderTop(0)
  setBorderBottom(65) -- bisschen Platz fuer Statuszeile
  setBorderLeft(0)
  setBorderRight(0)

  -- Statuszeile malen. Layout wie folgt:
  -- Zeile 1: spieler (Name, Stufe), gift, trenner_1, vorsicht (Vorsicht, Fluchtrichtung)
  -- Zeile 2: ort_raum (Region, Raumnummer, Para), ort_region (Ort kurz)
  -- Zeile 3: lp_titel, lp_anzeige (Lebenspunkte-Anzeige), kp_titel, kp_anzeige (KP-Anzeige), trenner_2

  GUI.statuszeile = Geyser.Container:new({name = "statuszeile", x=0, y=-70, width = 600, height=70})

  -- Zeile 1
  GUI.spieler = Geyser.Label:new({
    name = "spieler",
    x = 0, y = -65,
    width = 150, height = 20}, GUI.statuszeile)

  GUI.gift = Geyser.Label:new({
    name = "gift",
    x = 150, y = -65,
    width = 50, height = 20}, GUI.statuszeile)

  GUI.trenner_1 = Geyser.Label:new({
    name = "trenner_1",
    x = 200, y = -65,
    width = 50, height = 20}, GUI.statuszeile)

  GUI.vorsicht = Geyser.Label:new({
    name = "vorsicht",
    x = 250, y = -65,
    width = 350, height = 20}, GUI.statuszeile)

  -- Zeile 2
  GUI.ort_raum = Geyser.Label:new({
    name = "ort_raum",
    x = 250, y = -45,
    width = 350, height = 20}, GUI.statuszeile)

  GUI.ort_region = Geyser.Label:new({
    name = "ort_region",
    x = 0, y = -45,
    width = 250, height = 20}, GUI.statuszeile)

  -- Zeile 3
  GUI.lp_titel = Geyser.Label:new({
    name = "lp_titel",
    x = 0, y = -25,
    width = 100, height = 20}, GUI.statuszeile)
  GUI.lp_titel:echo("Lebenspunkte:")

  GUI.lp_anzeige = Geyser.Gauge:new({
    name = "lp_anzeige",
    x = 100, y = -25,
    width = 140, height = 20}, GUI.statuszeile)
  GUI.lp_anzeige:setColor(0, 255, 50)

  GUI.kp_titel = Geyser.Label:new({
    name = "kp_titel",
    x = 240, y = -25,
    width = 110, height = 20}, GUI.statuszeile)
  GUI.kp_titel:echo("&amp;nbsp;Konzentration:")

  GUI.kp_anzeige = Geyser.Gauge:new({
    name = "kp_anzeige",
    x = 350, y = -25,
    width = 150, height = 20}, GUI.statuszeile)
  GUI.kp_anzeige:setColor(0, 50, 250)

  GUI.trenner_2 = Geyser.Label:new({
    name = "trenner_2",
    x = 500, y = -25,
    width = 100, height = 20}, GUI.statuszeile)

end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>mapper</name>
			<packageName>mapper</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Initialisierung</name>
				<packageName></packageName>
				<script>
-- Entfernt Mudlets generic mapper package
uninstallPackage("generic_mapper")

mudlet = mudlet or {}
mudlet.mapper_script = true

mapper = {}

mapper.mode = "fix"
mapper.currentHash = nil
mapper.currentArea = "world"

function echoM(str)
    fg(mapperconf.color)
    echo("[MAPPER] " .. str .. "\n")
    resetFormat()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Areas</name>
				<packageName></packageName>
				<script>
-- Sucht die Area-ID fuer eine Area bzw. erstellt bei bedarf
-- eine neue Area.
function findArea(name)
    local areas = getAreaTable()
    if areas[name] == nil then
        return addAreaName(name)
    else
        return areas[name]
    end
end

            </script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Modes</name>
				<packageName></packageName>
				<script>
-- Aendert den Mapper Mode und gibt eine entsprechende Meldung aus.
function setMapperMode(mode)
    if mode == "fix" or mode == "auto" then
        echoM("Aendere Mapper-Modus nach: " .. mode)
        mapper.mode = mode
    else
        echoM("Fehler: Unbekannter Modus: '" .. mode .. "'")
    end
end

            </script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Ausgaenge</name>
				<packageName></packageName>
				<script>
mapper.exitmap =
    { n = 1
    , no = 2
    , nw = 3
    , o = 4
    , w = 5
    , s = 6
    , so = 7
    , sw = 8
    , ob = 9
    , u = 10
    , rein = 11
    , raus = 12
    , [1] = "n"
    , [2] = "no"
    , [3] = "nw"
    , [4] = "o"
    , [5] = "w"
    , [6] = "s"
    , [7] = "so"
    , [8] = "sw"
    , [9] = "ob"
    , [10] = "u"
    , [11] = "rein"
    , [12] = "raus"
    , norden = 1
    , nordosten = 2
    , nordwesten = 3
    , osten = 4
    , westen = 5
    , sueden = 6
    , suedosten = 7
    , suedwesten = 8
    , oben = 9
    , unten = 10
    }

mapper.intexitmap =
    { north = 1
    , northeast = 2
    , northwest = 3
    , east = 4
    , west = 5
    , south = 6
    , southeast = 7
    , southwest = 8
    , up = 9
    , down = 10
    , ["in"] = 11
    , out = 12
    , [1] = "north"
    , [2] = "northeast"
    , [3] = "northwest"
    , [4] = "east"
    , [5] = "west"
    , [6] = "south"
    , [7] = "southeast"
    , [8] = "southwest"
    , [9] = "up"
    , [10] = "down"
    , [11] = "in"
    , [12] = "out"
    , n = 1
    , ne = 2
    , nw = 3
    , e = 4
    , w = 5
    , s = 6
    , se = 7
    , sw = 8
    }

-- Der ganze Kram hier ist dazu da, verschiedene Repraesentationen der
-- Standardausgaenge ineinander zu konvertieren. Standardausgaenge
-- koennen auf drei Arten repraesentiert sein:
--
-- * Loc(al):    Die deutschen Abkuerzungen, die auch im MUD verwendet werden.
-- * Int(ernal): Englische Langversionen ("east", "west", etc.). Wird z.B. von
--               getRoomExits zurueckgegeben.
-- * Num(eric):  Numerische Repraesentationen der Standardausgaenge von 1-12
--               (siehe mapper.exitmap und mapper.intexitmap)

function exitNum2Int(n) return mapper.intexitmap[n] end
function exitNum2Loc(n) return mapper.exitmap[n] end
function exitInt2Loc(n) return mapper.exitmap[mapper.intexitmap[n]] end
function exitInt2Num(n) return mapper.intexitmap[n] end
function exitLoc2Int(n) return mapper.intexitmap[mapper.exitmap[n]] end
function exitLoc2Num(n) return mapper.exitmap[n] end

function isSpecialExit(name) return mapper.exitmap[name] == nil end
function isSpecialIntExit(name) return mapper.intexitmap[name] == nil end

-- Zur Positionierung neuer Raeume. Weist jeder Standardrichtung ein
-- Koordinatendelta zu.
function getExitCoordinates(name)
    local d = mapperconf.scale
    if name == "n" or name == "norden" then
        return 0, d, 0
    elseif name == "no" or name == "nordosten" then
        return d, d, 0
    elseif name == "o" or name == "osten" then
        return d, 0, 0
    elseif name == "so" or name == "suedosten" then
        return d, -d, 0
    elseif name == "s" or name == "sueden" then
        return 0, -d, 0
    elseif name == "sw" or name == "suedwesten" then
        return -d, -d, 0
    elseif name == "w" or name == "westen" then
        return -d, 0, 0
    elseif name == "nw" or name == "nordwesten" then
        return -d, d, 0
    elseif name == "ob" or name == "oben" then
        return 0, 0, 1
    elseif name == "u" or name == "unten" then
        return 0, 0, -1
    else
        return 0, 0, 0
    end
end

-- Baut (je nach Name) einen Standard- oder Spezialausgang.
function addAnyExit(src, tgt, name)
    if name == "" then
      return true
    end
    if isSpecialExit(name) then
        addSpecialExit(src, tgt, name)
        echoM("Erstelle speziellen Ausgang.\n  Quelle: " .. src .. "\n  Ziel:   " .. tgt .. "\n  Befehl: " .. name)
    else
        setExit(src, tgt, exitLoc2Num(name))
        echoM("Erstelle Ausgang.\n  Quelle: " .. src .. "\n  Ziel:   " .. tgt .. "\n  Befehl: " .. name)
    end
end

-- Sucht in einem Raum nach einem Ausgang mit einem bestimmten Namen.
function getAnyExit(room, name)
    if isSpecialExit(name) then
        return getSpecialExitsSwap(room)[name]
    else
        return getRoomExits(room)[exitLoc2Int(name)]
    end
end

function addStubExit(src, name)
    -- Debug: -- echoM("Prüfe Stub.  Start: " .. src .. "  Befehl: " .. name )
    if getAnyExit(src, name) then
        -- Debug: echoM("Befehl '" .. name .. "' uebersprungen, da bereits ein Ausgang dorthin vorlag.")
        return
    end
    if isSpecialExit(name) then
        -- Ausgänge wie "nordunten" werden (noch) nicht unterstützt
        -- Debug: echoM("Befehl '" .. name .. "' uebersprungen, nicht in ueblicher Richtung.")
        return
    end
    -- Debug: echoM("Erstelle Stub.  Befehl: " .. name)
    setExitStub(src, exitLoc2Num(name), true)
end

-- Erstellt einen neuen Raum mit Area und Hash und gibt eine Meldung aus.
function createRoom(area, hash)
    local newRoom = createRoomID()
    addRoom(newRoom)
    setRoomArea(newRoom, findArea(area))
    setRoomIDbyHash(newRoom, hash)
    echoM("Erstelle Raum.\n  Area: " .. area .. "\n  Hash: " .. hash)
    return newRoom
end

            </script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>handleRoomInfo</name>
				<packageName></packageName>
				<script>
-- Handler fuer gmcp.MG.room.info
-- Hier werden Raeume gebaut, Ausgaenge verbunden und die aktuelle Position in der Map
-- gesetzt.
function handleRoomInfo()
    local hash = gmcp.MG.room.info.id

    -- Manchmal kam das irgendwie doppelt. Fangen wir hier ab.
    if hash == mapper.currentHash then
        return true
    end

    mapper.currentHash = hash

    local exitname = command
    local knownRoom = getRoomIDbyHash(hash)

    if mapper.mode == "auto" then
        -- Raeume ohne Raum-ID kann der Automapper nicht.
        if hash == "" or hash == nil then
            echoM("Keine Raum-ID gefunden. Deaktiviere auto-mapper.")
            setMapperMode("fix")
            return true
        end

        mapper.synchronized = false

        if knownRoom == -1 then
            -- Neuer Raum ist nicht bekannt. Erstelle Raum und entsprechenden Ausgang

            local newRoom = createRoom(mapper.currentArea, hash)
            local roomName = gmcp.MG.room.info.short
            setRoomName(newRoom, roomName)

            local x,y,z = getRoomCoordinates(mapper.currentRoom)
            local dx,dy,dz = getExitCoordinates(exitname)
            setRoomCoordinates(newRoom, x+dx, y+dy, z+dz)

            addAnyExit(mapper.currentRoom, newRoom, exitname)
            mapper.currentRoom = newRoom
        else
            -- Neuer Raum ist bekannt. Erstelle nur einen Ausgang.

            if not getAnyExit(mapper.currentRoom, exitname) then
                addAnyExit(mapper.currentRoom, knownRoom, exitname)
            end

            mapper.currentRoom = knownRoom
            mapper.currentArea = getRoomAreaName(getRoomArea(mapper.currentRoom))
        end

        -- im neuen Raum alle sichtbaren Ausgänge prüfen und ggf. Stubs erzeugen
        for _, exitname in pairs(gmcp.MG.room.info.exits) do
            addStubExit(mapper.currentRoom, exitname)
        end

    elseif mapper.mode == "fix" then
        -- fix-Modus. Nur den aktuellen Raum setzen.
        if knownRoom &gt; -1 then
            mapper.currentRoom = knownRoom
            mapper.currentArea = getRoomAreaName(getRoomArea(mapper.currentRoom))
        end
    end
    centerview(mapper.currentRoom)
end

            </script>
				<eventHandlerList>
					<string>gmcp.MG.room.info</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>doSpeedWalk</name>
				<packageName></packageName>
				<script>
function doSpeedWalk()
    command = ""
    local save_mode = mapper.mode
    mapper.mode = "fix"
    send("ultrakurz", false)
    for i,d in ipairs(speedWalkDir) do
        if isSpecialIntExit(d)
        then
          send(d, false)
        else
        	send(exitInt2Loc(d), false)
		end
    end
    command = ""
    send("lang", false)
    send("schau", false)
    mapper.mode = save_mode
end

            </script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>settings</name>
			<packageName>settings</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Einstellungen</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Farben</name>
					<packageName></packageName>
					<script>
farben = {}
farben.vg =
  { komm = "cyan",
    ebenen = "magenta",
    info = "green",
    alarm = "white",
    script = "dark_green" }
farben.hg =
  { komm = "black",
    ebenen = "black",
    info = "black",
    alarm = "red",
    script = "black" }

-- komm: Kommunikation wie teile-mit
-- ebenen: Einfaerben der "normalen" Ebenen
-- info: Einfaerben von Informationen des Muds (Status Gegner)
-- alarm: Alarm-Nachrichten
-- script: Nachrichten, die nicht vom Mud, sondern von einem Script stammen.

-- Einstellungen fuer Farben Kampfscroll

function msg (type, what)
  -- setzt VG und HG je nach Typ der Kommunikation
  local vg = farben.vg[type]
  local hg = farben.hg[type]

  if vg and hg then
      cecho("&lt;"..vg..":"..hg.."&gt;"..what)
  else
    echo(what)
  end
end

                </script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Mapper</name>
					<packageName></packageName>
					<script>
mapperconf = mapperconf or {}

-------------------------------------------------------
-- Benutzerdefinierte Einstellungen fuer den Mapper. --
-------------------------------------------------------

-- Farbe fuer Mitteilungen des Mappers
mapperconf.color = mapperconf.color or "royal_blue"
-- Standardabstand zwischen zwei Raeumen
mapperconf.scale = mapperconf.scale or 2

                </script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>krrrcks</name>
			<packageName>krrrcks</packageName>
			<script></script>
			<command></command>
			<keyCode>0</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Keypad</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>-1</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>8: norden</name>
					<packageName></packageName>
					<script></script>
					<command>norden</command>
					<keyCode>56</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>0: schau</name>
					<packageName></packageName>
					<script></script>
					<command>schau</command>
					<keyCode>48</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>5: schau</name>
					<packageName></packageName>
					<script></script>
					<command>schau</command>
					<keyCode>53</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>+: unten</name>
					<packageName></packageName>
					<script></script>
					<command>unten</command>
					<keyCode>43</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>-: oben</name>
					<packageName></packageName>
					<script></script>
					<command>oben</command>
					<keyCode>45</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>1: suedwesten</name>
					<packageName></packageName>
					<script></script>
					<command>suedwesten</command>
					<keyCode>49</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>3: suedosten</name>
					<packageName></packageName>
					<script></script>
					<command>suedosten</command>
					<keyCode>51</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>7: nordwesten</name>
					<packageName></packageName>
					<script></script>
					<command>nordwesten</command>
					<keyCode>55</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>9: nordosten</name>
					<packageName></packageName>
					<script></script>
					<command>nordosten</command>
					<keyCode>57</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>4: westen</name>
					<packageName></packageName>
					<script></script>
					<command>westen</command>
					<keyCode>52</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>6: osten</name>
					<packageName></packageName>
					<script></script>
					<command>osten</command>
					<keyCode>54</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>2: sueden</name>
					<packageName></packageName>
					<script></script>
					<command>sueden</command>
					<keyCode>50</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>x: raus</name>
					<packageName></packageName>
					<script></script>
					<command>raus</command>
					<keyCode>42</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>/: kurz</name>
					<packageName></packageName>
					<script>local newmodus = ""

if ME.modus == "lang" then
  newmodus = "kurz"
elseif ME.modus == "kurz" then
  newmodus = "ultrakurz"
elseif ME.modus == "ultrakurz" then
  newmodus = "lang"
else
  newmodus = "kurz"
end

ME.modus = newmodus
send(newmodus)</script>
					<command></command>
					<keyCode>47</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>,: ausruestung</name>
					<packageName></packageName>
					<script></script>
					<command>ausruestung</command>
					<keyCode>44</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
